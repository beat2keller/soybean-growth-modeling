field_dates = sort(unique(df_field$date))
missing_dates = setdiff(as.character(field_dates), as.character(df_plot$date))
df_plot_max_PH = df_plot[df_plot$date == max(df_plot$date),]
for (missing_date in missing_dates) {
df_plot_max_PH$date = as.Date(missing_date)
df_temp = rbind(df_temp, df_plot_max_PH)
}
}
}
soybeans = left_join(soybeans,df_temp )
# renaming
soybeans$Date <- soybeans$date
soybeans$date <- NULL # dropping lower case date column
soybeans$Location <- soybeans$location
soybeans$Year <- as.character(soybeans$year)
soybeans <- setDT(soybeans)
soybeans <- unique(soybeans)
#pivot longer
soybeans_melt = melt.data.table(soybeans, measure.vars = c("CC"))
# considering only the growth period, this pipelines returns the same data points as the data_aggregation_cc file from last year.
# Nut without plotting, spatial_cc and other things unnecessary for the modelling
write.csv(soybeans_melt, "data/soybean_data_for_modelling.csv")
# this file joins the weather with the soybean data for modelling. Creates model_data.csv
library(data.table)
weathter_data = fread("data/weather_data_for_modelling.csv")
soybean_data = fread("data/soybean_data_for_modelling.csv")
# only keep the necessary subset of the weather data
Weather_data_sub <- subset(weathter_data,as.character(Date)%in%as.character(c(soybean_data$Date,soybean_data$date_of_sowing)))
# include weather at sowing as varible
WeatherAtSowing <- unique(Weather_data_sub)
WeatherAtSowing$WeatherValueAtSowing <- WeatherAtSowing$WeatherValue
PhenoWeatherData <- merge.data.table(soybean_data, Weather_data_sub, by=c("Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- merge.data.table(PhenoWeatherData, WeatherAtSowing[,c("Location","Date","Year","WeatherVariable","WeatherValueAtSowing")], by.x=c("WeatherVariable","Location","date_of_sowing","Year"), by.y=c("WeatherVariable","Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- PhenoWeatherData[!is.na(PhenoWeatherData$WeatherVariable),]
# sowing to measure variables
PhenoWeatherData$Sowing_to_Measure <- PhenoWeatherData$WeatherValue-PhenoWeatherData$WeatherValueAtSowing
PhenoWeatherData <- PhenoWeatherData[order(PhenoWeatherData$Date),]
# calculate new measures : still unclear
# commented out on 2.4 based on changes made in the original repo:
#PhenoWeatherData <- PhenoWeatherData[,list(Sowing_to_Measure=mean(Sowing_to_Measure, na.rm=T), Measure_7=mean(Measure_7, na.rm=T), Measure_14=mean(Measure_14, na.rm=T), Measure_56=mean(Measure_56, na.rm=T), Measure_28=mean(Measure_28, na.rm=T)), by=.(Filename,genotype.name,genotype.id,Year,Location,year_site.UID,plot_number,plot.UID,plot_grouped,range,row,Date,value,variable,variable.1,WeatherVariable,WeatherCalcVar,date_of_sowing, platform)]
PhenoWeatherData_cast <- dcast.data.table(PhenoWeatherData, Filename+genotype.name+genotype.id+Year+Location+year_site.UID+plot_number+plot.UID+plot_grouped+range+row+Date+value+variable+variable.1+date_of_sowing+platform~WeatherVariable, value.var=c("Sowing_to_Measure","Measure_7","Measure_14","Measure_56","Measure_28")) # ~WeatherVariable+WeatherCalcVar
# make changes that were made in the original modelling file -----
# create new variables
PhenoWeatherData_cast$time_since_sowing =( as.numeric(as.Date(PhenoWeatherData_cast$Date )-as.Date( PhenoWeatherData_cast$date_of_sowing)))
# rename variables, and keep only a subset of the variables
model_df = data.frame(matrix(nrow=nrow(PhenoWeatherData_cast), ncol=0))
model_df$UID          <- PhenoWeatherData_cast$plot.UID
model_df$year         <- PhenoWeatherData_cast$Year
model_df$value <- PhenoWeatherData_cast$value
model_df$time_since_sowing <- PhenoWeatherData_cast$time_since_sowing
model_df$genotype.id  <- PhenoWeatherData_cast$genotype.id
model_df$date         <- PhenoWeatherData_cast$Date
model_df$plot_grouped <- PhenoWeatherData_cast$plot_grouped
model_df$year_site.UID <- PhenoWeatherData_cast$year_site.UID
model_df$range <- PhenoWeatherData_cast$range
model_df$row <- PhenoWeatherData_cast$row
model_df$Filename <- PhenoWeatherData_cast$Filename
model_df$Location <- PhenoWeatherData_cast$Location
model_df$platform = PhenoWeatherData_cast$platform
# type conversiion
model_df$year          <- ordered(as.numeric(model_df$year))
model_df$genotype.id   <- as.factor(model_df$genotype.id)
model_df$plot_grouped   <- ordered(as.factor(model_df$plot_grouped))
model_df$date          <- as.Date(model_df$date)
# measure variables
model_df$avg_Temperature_56 <- (PhenoWeatherData_cast$Measure_56_Temperature)
model_df$avg_Temperature_28 <- (PhenoWeatherData_cast$Measure_28_Temperature)
model_df$avg_precipitation_56 <- (PhenoWeatherData_cast$Measure_56_Precipitation)
model_df$avg_precipitation_28 <- (PhenoWeatherData_cast$Measure_28_Precipitation)
model_df$avg_radiation_28 <- (PhenoWeatherData_cast$Measure_28_RadiationSqrt)
model_df$avg_photothermal_14 <- (PhenoWeatherData_cast$Measure_28_PhotoSqrtThermal)
model_df$avg_vpd_28 <- (PhenoWeatherData_cast$Measure_28_VPD)
model_df$avg_humidity_28 <- (PhenoWeatherData_cast$Measure_28_Humidity)
###### add row per plot information
model_df$Row_per_plot <- 3
model_df$Row_per_plot[model_df$year_site.UID%in%c("FPSB004","FPSB005","FPSB007")] <- 9
######
model_df <- model_df[!is.na(model_df$value),]
model_df <- model_df[!is.nan(model_df$value),]
model_df <- model_df[!is.na(model_df$genotype.id),]
###### create new grouping. up for changing
setDT(model_df)[,length(unique(UID)),by=plot_grouped]
df_for_grouping = model_df[,c("range","row","year_site.UID")]
df_for_grouping = unique(df_for_grouping)
df_for_grouping <- df_for_grouping[order(df_for_grouping$year_site.UID,df_for_grouping$row, df_for_grouping$range),]
df_for_grouping$row_reduced <- round((df_for_grouping$row+2)/4, digits = 0)*4
df_for_grouping$range_reduced <- round((df_for_grouping$range+1)/2, digits = 0)*2
# MISTAKE here
# This pipeline uses soybean_pixels_data.csv to make a df that can be joined with the weather data
# output is call soybean_data_for_modelling.csv
# packages ---------
library(data.table)
library(stringr)
library(tidyverse)
#load data ---------
soybeans_FIP_UAV <- fread("data/soybean_pixels_data.csv")
# New classification of growth and senescence period:
# to account for the fact that the maximum canopy cover might not be the actual end of the growth phase,
# but occur after a long fluctuation, we take the max value of the first long continuous growth period as end of growth.
# Therefore, we check in the neighbourhood of the max value if there was a decline.
# If so, this indicates fluctuation and we take the max vale before the fluctuation as end of growth.
for (id in unique(soybeans_FIP_UAV$plot.UID)) {
subs = subset(soybeans_FIP_UAV, plot.UID == id)
max = which(subs$Canopy_cover == max(subs$Canopy_cover)) # find the index of the maximum value
c_max = min(which(subs$Canopy_cover > max(subs$Canopy_cover)-0.02))  # find the minimum index with a canopy cover close to the maximum (0.02 under)
rel = max(subs$Canopy_cover) # store the maximum value
if (max > c_max) {
for (i in c_max:(max-1)) {
if (subs$Canopy_cover[i] > subs$Canopy_cover[i+1]) { # check if there is a decline closely before the max is reached (indication for fluctuation)
rel = subs$Canopy_cover[i] # if so, take the maximum value before the decline as the end of growth
break } } }
growth_end = which(subs$Canopy_cover==rel) # define the index of the end of growth
for (i in 1:nrow(subs)) {  # define the observations before end of growth as "Growth" and after as "Senescence"
if (i <= growth_end) {soybeans_FIP_UAV[which(soybeans_FIP_UAV[,"plot.UID"] == id), "Period"][i,]  = "Growth"}
if (i > growth_end) {soybeans_FIP_UAV[which(soybeans_FIP_UAV[,"plot.UID"] == id), "Period"][i,] = "Senescence"}
}
}
# rename variables
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "plot.range"] <- "range"
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "plot.row"] <- "row"
soybeans_FIP_UAV$value <- soybeans_FIP_UAV$value_relative # this creates an additional column value that has the same entries
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "Date"] <- "date"
# restrict to subsets of the data that are needed for the model
soybeans = subset(soybeans_FIP_UAV, Period=="Growth" &  variable == "Canopy_cover")
# clean data
soybeans = unique(soybeans)
soybeans = soybeans[!is.na(soybeans$value),]
soybeans = soybeans[!is.na(soybeans$genotype.id),]
soybeans <- soybeans[,c("Filename","genotype.name","genotype.id","plot.UID","range","row","Time","location","year_site.UID" ,"date","variable","Period","time_since_sowing","date_of_sowing","platform", "value")]
soybeans = unique(soybeans)
soybeans[soybeans$value < 0,]$value = 0 # do not allow negative CC
# order the df
soybeans = soybeans[order(soybeans$variable, soybeans$plot.UID, soybeans$date),]
#transform the plot UIDs into strings of integers
soybeans$plot_number = strtoi(str_sub(soybeans$plot.UID, -3), 10)
# Time since sowing ------
soybeans$date <- as.Date(soybeans$date)
soybeans$year = year(soybeans$date)
# Change wrongly measured fields
temp = soybeans[soybeans$year_site.UID=='FPSB006',]$range
soybeans[soybeans$year_site.UID=='FPSB006',]$range = soybeans[soybeans$year_site.UID=='FPSB006',]$row
soybeans[soybeans$year_site.UID=='FPSB006',]$row = temp
# Spatial grouping -----
max_rows_and_ranges = soybeans %>% group_by(year_site.UID) %>% summarize(max_row = max(row))
soybeans = merge(soybeans, max_rows_and_ranges, all.x = TRUE)
soybeans$row_grouped = floor((soybeans$row - 1)/ 3) + 1
soybeans[soybeans$max_row %% 3 == 1 & soybeans$row == soybeans$max_row,]$row_grouped = soybeans[soybeans$max_row %% 3 == 1 & soybeans$row == soybeans$max_row,]$row_grouped - 1
soybeans <- soybeans %>%
group_by(year_site.UID, range, row_grouped) %>%
mutate(plot_grouped = as.factor(cur_group_id()))
# indicator for closeness to border is omitted
soybeans <- soybeans[, !names(soybeans) %in% c('distance_to_border', 'distance_to_border_row_grouped', 'distance_to_border_range', 'max_row_grouped', 'max_range')]
# we keep the plot_groupded variable, but we might define a new grouping later
# rename variables again -------
colnames(soybeans)[colnames(soybeans) == "value"] <- "CC"
# symbols like / and % create problems later on, they should not be used in variable names
colnames(soybeans) <- gsub("/", "", colnames(soybeans))
colnames(soybeans) <- gsub("%", "", colnames(soybeans))
# filling in missing dates - take from R file of prev. year
df_temp = subset(soybeans)
unique_field_UIDs = sort(unique(soybeans$year_site.UID))
for (field_UID in unique_field_UIDs) {
df_field = df_temp[df_temp$year_site.UID == field_UID,]
plot_numbers = unique(df_field$plot_number)
for (plot_number in plot_numbers) {
df_plot = df_field[df_field$plot_number == plot_number,]
field_dates = sort(unique(df_field$date))
missing_dates = setdiff(as.character(field_dates), as.character(df_plot$date))
df_plot_max_PH = df_plot[df_plot$date == max(df_plot$date),]
for (missing_date in missing_dates) {
df_plot_max_PH$date = as.Date(missing_date)
df_temp = rbind(df_temp, df_plot_max_PH)
}
}
}
soybeans = left_join(soybeans,df_temp )
# renaming
soybeans$Date <- soybeans$date
soybeans$date <- NULL # dropping lower case date column
soybeans$Location <- soybeans$location
soybeans$Year <- as.character(soybeans$year)
soybeans <- setDT(soybeans)
soybeans <- unique(soybeans)
#pivot longer
soybeans_melt = melt.data.table(soybeans, measure.vars = c("CC"))
# considering only the growth period, this pipelines returns the same data points as the data_aggregation_cc file from last year.
# Nut without plotting, spatial_cc and other things unnecessary for the modelling
write.csv(soybeans_melt, "data/soybean_data_for_modelling.csv")
names(soybeans_melt)
head(soybeans_melt)
# this file joins the weather with the soybean data for modelling. Creates model_data.csv
library(data.table)
weathter_data = fread("data/weather_data_for_modelling.csv")
soybean_data = fread("data/soybean_data_for_modelling.csv")
# only keep the necessary subset of the weather data
Weather_data_sub <- subset(weathter_data,as.character(Date)%in%as.character(c(soybean_data$Date,soybean_data$date_of_sowing)))
# include weather at sowing as varible
WeatherAtSowing <- unique(Weather_data_sub)
WeatherAtSowing$WeatherValueAtSowing <- WeatherAtSowing$WeatherValue
PhenoWeatherData <- merge.data.table(soybean_data, Weather_data_sub, by=c("Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- merge.data.table(PhenoWeatherData, WeatherAtSowing[,c("Location","Date","Year","WeatherVariable","WeatherValueAtSowing")], by.x=c("WeatherVariable","Location","date_of_sowing","Year"), by.y=c("WeatherVariable","Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- PhenoWeatherData[!is.na(PhenoWeatherData$WeatherVariable),]
# sowing to measure variables
PhenoWeatherData$Sowing_to_Measure <- PhenoWeatherData$WeatherValue-PhenoWeatherData$WeatherValueAtSowing
PhenoWeatherData <- PhenoWeatherData[order(PhenoWeatherData$Date),]
# commented out on 2.4 based on changes made in the original repo:
#PhenoWeatherData <- PhenoWeatherData[,list(Sowing_to_Measure=mean(Sowing_to_Measure, na.rm=T), Measure_7=mean(Measure_7, na.rm=T), Measure_14=mean(Measure_14, na.rm=T), Measure_56=mean(Measure_56, na.rm=T), Measure_28=mean(Measure_28, na.rm=T)), by=.(Filename,genotype.name,genotype.id,Year,Location,year_site.UID,plot_number,plot.UID,plot_grouped,range,row,Date,value,variable,variable.1,WeatherVariable,WeatherCalcVar,date_of_sowing, platform)]
PhenoWeatherData_cast <- dcast.data.table(PhenoWeatherData, Filename+genotype.name+genotype.id+Year+Location+year_site.UID+plot_number+plot.UID+plot_grouped+range+row+Date+value+variable+variable.1+date_of_sowing+platform~WeatherVariable, value.var=c("Sowing_to_Measure","Measure_7","Measure_14","Measure_56","Measure_28")) # ~WeatherVariable+WeatherCalcVar
PhenoWeatherData_cast
sum(PhenoWeatherData_cast$Measure_14_PhotothermalTime > 1)
dim(PhenoWeatherData)
dim(PhenoWeatherData_cast)
PhenoWeatherData
# commented out on 2.4 based on changes made in the original repo:
#PhenoWeatherData <- PhenoWeatherData[,list(Sowing_to_Measure=mean(Sowing_to_Measure, na.rm=T), Measure_7=mean(Measure_7, na.rm=T), Measure_14=mean(Measure_14, na.rm=T), Measure_56=mean(Measure_56, na.rm=T), Measure_28=mean(Measure_28, na.rm=T)), by=.(Filename,genotype.name,genotype.id,Year,Location,year_site.UID,plot_number,plot.UID,plot_grouped,range,row,Date,value,variable,variable.1,WeatherVariable,WeatherCalcVar,date_of_sowing, platform)]
PhenoWeatherData_cast <- dcast.data.table(unique(PhenoWeatherData), Filename+genotype.name+genotype.id+Year+Location+year_site.UID+plot_number+plot.UID+plot_grouped+range+row+Date+value+variable+variable.1+date_of_sowing+platform~WeatherVariable, value.var=c("Sowing_to_Measure","Measure_7","Measure_14","Measure_56","Measure_28")) # ~WeatherVariable+WeatherCalcVar
dim(unique(PhenoWeatherData))
dim(PhenoWeatherData)
# commented out on 2.4 based on changes made in the original repo:
#PhenoWeatherData <- PhenoWeatherData[,list(Sowing_to_Measure=mean(Sowing_to_Measure, na.rm=T), Measure_7=mean(Measure_7, na.rm=T), Measure_14=mean(Measure_14, na.rm=T), Measure_56=mean(Measure_56, na.rm=T), Measure_28=mean(Measure_28, na.rm=T)), by=.(Filename,genotype.name,genotype.id,Year,Location,year_site.UID,plot_number,plot.UID,plot_grouped,range,row,Date,value,variable,variable.1,WeatherVariable,WeatherCalcVar,date_of_sowing, platform)]
PhenoWeatherData_cast <- dcast.data.table(PhenoWeatherData, Filename+genotype.name+genotype.id+Year+Location+year_site.UID+plot_number+plot.UID+plot_grouped+range+row+Date+value+variable+variable.1+date_of_sowing+platform~WeatherVariable, value.var=c("Sowing_to_Measure","Measure_7","Measure_14","Measure_56","Measure_28"),fun.aggregate = mean) # ~WeatherVariable+WeatherCalcVar
dim8PhenoWeatherData_cast
dim(PhenoWeatherData_cast)
# create new variables
PhenoWeatherData_cast$time_since_sowing =( as.numeric(as.Date(PhenoWeatherData_cast$Date )-as.Date( PhenoWeatherData_cast$date_of_sowing)))
model_df = data.frame(matrix(nrow=nrow(PhenoWeatherData_cast), ncol=0))
model_df$UID          <- PhenoWeatherData_cast$plot.UID
model_df$year         <- PhenoWeatherData_cast$Year
model_df$value <- PhenoWeatherData_cast$value
model_df$time_since_sowing <- PhenoWeatherData_cast$time_since_sowing
model_df$genotype.id  <- PhenoWeatherData_cast$genotype.id
model_df$date         <- PhenoWeatherData_cast$Date
model_df$plot_grouped <- PhenoWeatherData_cast$plot_grouped
model_df$year_site.UID <- PhenoWeatherData_cast$year_site.UID
model_df$range <- PhenoWeatherData_cast$range
model_df$row <- PhenoWeatherData_cast$row
model_df$Filename <- PhenoWeatherData_cast$Filename
model_df$Location <- PhenoWeatherData_cast$Location
model_df$platform = PhenoWeatherData_cast$platform
# type conversiion
model_df$year          <- ordered(as.numeric(model_df$year))
model_df$genotype.id   <- as.factor(model_df$genotype.id)
model_df$plot_grouped   <- ordered(as.factor(model_df$plot_grouped))
model_df$date          <- as.Date(model_df$date)
# measure variables
model_df$avg_Temperature_56 <- (PhenoWeatherData_cast$Measure_56_Temperature)
model_df$avg_Temperature_28 <- (PhenoWeatherData_cast$Measure_28_Temperature)
model_df$avg_precipitation_56 <- (PhenoWeatherData_cast$Measure_56_Precipitation)
model_df$avg_precipitation_28 <- (PhenoWeatherData_cast$Measure_28_Precipitation)
model_df$avg_radiation_28 <- (PhenoWeatherData_cast$Measure_28_RadiationSqrt)
model_df$avg_photothermal_14 <- (PhenoWeatherData_cast$Measure_28_PhotoSqrtThermal)
model_df$avg_vpd_28 <- (PhenoWeatherData_cast$Measure_28_VPD)
model_df$avg_humidity_28 <- (PhenoWeatherData_cast$Measure_28_Humidity)
###### add row per plot information
model_df$Row_per_plot <- 3
model_df$Row_per_plot[model_df$year_site.UID%in%c("FPSB004","FPSB005","FPSB007")] <- 9
model_df <- model_df[!is.na(model_df$value),]
model_df <- model_df[!is.nan(model_df$value),]
model_df <- model_df[!is.na(model_df$genotype.id),]
###### create new grouping. up for changing
setDT(model_df)[,length(unique(UID)),by=plot_grouped]
df_for_grouping = model_df[,c("range","row","year_site.UID")]
df_for_grouping = unique(df_for_grouping)
df_for_grouping <- df_for_grouping[order(df_for_grouping$year_site.UID,df_for_grouping$row, df_for_grouping$range),]
df_for_grouping$row_reduced <- round((df_for_grouping$row+2)/4, digits = 0)*4
df_for_grouping$range_reduced <- round((df_for_grouping$range+1)/2, digits = 0)*2
df_for_grouping$row_reduced
df_for_grouping$row_reduced <- round((df_for_grouping$row+2)/4, digits = 0)*4
df_for_grouping$range_reduced <- round((df_for_grouping$range+1)/2, digits = 0)*2
# MISTAKE here
df_for_grouping$plot_grouped_global <-  df_for_grouping$row_reduced * df_for_grouping$range_reduced
df_for_grouping$plot_grouped_global
df_for_grouping$row_reduced
df_for_grouping$range_reduced
df_for_grouping$plot_grouped_global
unique(df_for_grouping$plot_grouped_global)
library(nlme)
library(stringr)
library(ggplot2)
library(dplyr)
library(broom.mixed)
library(merTools)
library(data.table)
# data "plot_grouped_global" is used for the grouping of the data
df = read.csv("data/model_data.csv")
unique(df$plot_grouped_global)
### This file uses the imputed weather dataframe to make a weather df that can be joined with the soybean data
# Packages ------
library(data.table)
weather_load <- data.table::fread("data/Weather_imputed.csv")
# feature engineering ----
# Split the df into two for better manipulation
df_w_radiation  = subset(weather_load,WeatherVariable=="Radiation")
df_w_radiation$value[df_w_radiation$value>800] <- 800 # impose a cap on radiation
df_w_radiation$WeatherVariable <- "RadiationCap" # rename variable
weather <- rbind(weather_load, df_w_radiation)
df_w_temperature <- subset(weather,WeatherVariable=="Temperature")
df_w_temperature$value <- df_w_temperature$value*df_w_radiation$value # make phototermal variable
df_w_temperature$WeatherVariable <- "PhotoThermalCap"
weather <- rbind(weather, df_w_temperature)
# Renaming Lindau to Eschikon, necessary because of the name the weather api assigns
weather[weather$Location == "Lindau",]$Location = "Eschikon"
# we remove the na values. Based on the project from 2023 they only appeared in the winter and are thus not relevant
sum(is.na(weather$value))
weather = weather[!is.na(weather$value),]
# # Daytime / Nighttime variable ---------
#skipped for now as they are not used in the modelling
# format column -----
weather$Date <- as.Date(weather$DateTime)
weather_Eschikon = weather[weather$Location == "Eschikon",]
weather_Delley = weather[weather$Location == "Delley",]
weather = rbind(weather_Eschikon, weather_Delley)
# Group data and calculate mean and sd, use two dfs for different computation-----
Weather_data_Melt1 <- subset(weather,WeatherVariable!="Precipitation")[, list(dailymean=mean(value, na.rm = T),dailySD=sd(value, na.rm = T)), by=.(Date, Location, WeatherVariable) ] #, Imputed
Weather_data_Melt2 <- subset(weather,WeatherVariable=="Precipitation")[, list(dailymean=sum(value, na.rm = T),dailySD=sd(value, na.rm = T)), by=.(Date, Location, WeatherVariable) ] #, Imputedum(value, na.rm = T),dailySD=sd(value, na.rm = T)), by=.(Date, Location, WeatherVariable) ] #, Imputed
# define measure variables (toDo: What they mean):
Weather_data_cumulative <- rbind(Weather_data_Melt1, Weather_data_Melt2)
Weather_data_cumulative$Year <- format(as.Date(Weather_data_cumulative$Date, format="%Y-%m-%d"),"%Y")
Weather_data_cumulative[,CumulativeDailyMean:=cumsum(dailymean), by=.(Location, WeatherVariable, Year)]
Weather_data_cumulative[,cum_value:=cumsum(dailymean), by=.(Location, WeatherVariable, Year)]
Weather_data_cumulative[,Measure_7:=cum_value - shift(cum_value, fill = first(cum_value),n=7), by=.(Year,WeatherVariable,Location) ]
Weather_data_cumulative[,Measure_14:=cum_value - shift(cum_value, fill = first(cum_value),n=14), by=.(Year,WeatherVariable,Location)  ]
Weather_data_cumulative[,Measure_28:=cum_value - shift(cum_value, fill = first(cum_value),n=28), by=.(Year,WeatherVariable,Location)  ]
Weather_data_cumulative[,Measure_56:=cum_value - shift(cum_value, fill = first(cum_value),n=56), by=.(Year,WeatherVariable,Location)  ]
Weather_data_cumulative$cum_value <- NULL
Weather_data_Melt_cumulative <- melt.data.table(Weather_data_cumulative, id.vars=c("WeatherVariable","Location","Date","Year","Measure_7","Measure_14","Measure_28","Measure_56"),measure.vars = c("CumulativeDailyMean"),variable.name = "WeatherCalcVar",value.name="WeatherValue") ##,"SDoverTimeDailyMean"
# remove NA
Weather_data_Melt_cumulative <- Weather_data_Melt_cumulative[!is.na(Weather_data_Melt_cumulative$WeatherValue),]
#print(nrow(Weather_data_Melt_cumulative))
# save df -------
write.csv(Weather_data_Melt_cumulative, "data/weather_data_for_modelling.csv")
# This pipeline uses soybean_pixels_data.csv to make a df that can be joined with the weather data
# output is call soybean_data_for_modelling.csv
# packages ---------
library(data.table)
library(stringr)
library(tidyverse)
#load data ---------
soybeans_FIP_UAV <- fread("data/soybean_pixels_data.csv")
# New classification of growth and senescence period:
# to account for the fact that the maximum canopy cover might not be the actual end of the growth phase,
# but occur after a long fluctuation, we take the max value of the first long continuous growth period as end of growth.
# Therefore, we check in the neighbourhood of the max value if there was a decline.
# If so, this indicates fluctuation and we take the max vale before the fluctuation as end of growth.
for (id in unique(soybeans_FIP_UAV$plot.UID)) {
subs = subset(soybeans_FIP_UAV, plot.UID == id)
max = which(subs$Canopy_cover == max(subs$Canopy_cover)) # find the index of the maximum value
c_max = min(which(subs$Canopy_cover > max(subs$Canopy_cover)-0.02))  # find the minimum index with a canopy cover close to the maximum (0.02 under)
rel = max(subs$Canopy_cover) # store the maximum value
if (max > c_max) {
for (i in c_max:(max-1)) {
if (subs$Canopy_cover[i] > subs$Canopy_cover[i+1]) { # check if there is a decline closely before the max is reached (indication for fluctuation)
rel = subs$Canopy_cover[i] # if so, take the maximum value before the decline as the end of growth
break } } }
growth_end = which(subs$Canopy_cover==rel) # define the index of the end of growth
for (i in 1:nrow(subs)) {  # define the observations before end of growth as "Growth" and after as "Senescence"
if (i <= growth_end) {soybeans_FIP_UAV[which(soybeans_FIP_UAV[,"plot.UID"] == id), "Period"][i,]  = "Growth"}
if (i > growth_end) {soybeans_FIP_UAV[which(soybeans_FIP_UAV[,"plot.UID"] == id), "Period"][i,] = "Senescence"}
}
}
# rename variables
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "plot.range"] <- "range"
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "plot.row"] <- "row"
soybeans_FIP_UAV$value <- soybeans_FIP_UAV$value_relative # this creates an additional column value that has the same entries
colnames(soybeans_FIP_UAV)[colnames(soybeans_FIP_UAV) == "Date"] <- "date"
# restrict to subsets of the data that are needed for the model
soybeans = subset(soybeans_FIP_UAV, Period=="Growth" &  variable == "Canopy_cover")
# clean data
soybeans = unique(soybeans)
soybeans = soybeans[!is.na(soybeans$value),]
soybeans = soybeans[!is.na(soybeans$genotype.id),]
soybeans <- soybeans[,c("Filename","genotype.name","genotype.id","plot.UID","range","row","Time","location","year_site.UID" ,"date","variable","Period","time_since_sowing","date_of_sowing","platform", "value")]
soybeans = unique(soybeans)
soybeans[soybeans$value < 0,]$value = 0 # do not allow negative CC
# order the df
soybeans = soybeans[order(soybeans$variable, soybeans$plot.UID, soybeans$date),]
#transform the plot UIDs into strings of integers
soybeans$plot_number = strtoi(str_sub(soybeans$plot.UID, -3), 10)
# Time since sowing ------
soybeans$date <- as.Date(soybeans$date)
soybeans$year = year(soybeans$date)
# Change wrongly measured fields
temp = soybeans[soybeans$year_site.UID=='FPSB006',]$range
soybeans[soybeans$year_site.UID=='FPSB006',]$range = soybeans[soybeans$year_site.UID=='FPSB006',]$row
soybeans[soybeans$year_site.UID=='FPSB006',]$row = temp
# Spatial grouping -----
max_rows_and_ranges = soybeans %>% group_by(year_site.UID) %>% summarize(max_row = max(row))
soybeans = merge(soybeans, max_rows_and_ranges, all.x = TRUE)
soybeans$row_grouped = floor((soybeans$row - 1)/ 3) + 1
soybeans[soybeans$max_row %% 3 == 1 & soybeans$row == soybeans$max_row,]$row_grouped = soybeans[soybeans$max_row %% 3 == 1 & soybeans$row == soybeans$max_row,]$row_grouped - 1
soybeans <- soybeans %>%
group_by(year_site.UID, range, row_grouped) %>%
mutate(plot_grouped = as.factor(cur_group_id()))
# indicator for closeness to border is omitted
soybeans <- soybeans[, !names(soybeans) %in% c('distance_to_border', 'distance_to_border_row_grouped', 'distance_to_border_range', 'max_row_grouped', 'max_range')]
# we keep the plot_groupded variable, but we might define a new grouping later
# rename variables again -------
colnames(soybeans)[colnames(soybeans) == "value"] <- "CC"
# symbols like / and % create problems later on, they should not be used in variable names
colnames(soybeans) <- gsub("/", "", colnames(soybeans))
colnames(soybeans) <- gsub("%", "", colnames(soybeans))
# filling in missing dates - take from R file of prev. year
df_temp = subset(soybeans)
unique_field_UIDs = sort(unique(soybeans$year_site.UID))
for (field_UID in unique_field_UIDs) {
df_field = df_temp[df_temp$year_site.UID == field_UID,]
plot_numbers = unique(df_field$plot_number)
for (plot_number in plot_numbers) {
df_plot = df_field[df_field$plot_number == plot_number,]
field_dates = sort(unique(df_field$date))
missing_dates = setdiff(as.character(field_dates), as.character(df_plot$date))
df_plot_max_PH = df_plot[df_plot$date == max(df_plot$date),]
for (missing_date in missing_dates) {
df_plot_max_PH$date = as.Date(missing_date)
df_temp = rbind(df_temp, df_plot_max_PH)
}
}
}
soybeans = left_join(soybeans,df_temp )
# renaming
soybeans$Date <- soybeans$date
soybeans$date <- NULL # dropping lower case date column
soybeans$Location <- soybeans$location
soybeans$Year <- as.character(soybeans$year)
soybeans <- setDT(soybeans)
soybeans <- unique(soybeans)
#pivot longer
soybeans_melt = melt.data.table(soybeans, measure.vars = c("CC"))
# considering only the growth period, this pipelines returns the same data points as the data_aggregation_cc file from last year.
# Nut without plotting, spatial_cc and other things unnecessary for the modelling
write.csv(soybeans_melt, "data/soybean_data_for_modelling.csv")
# this file joins the weather with the soybean data for modelling. Creates model_data.csv
library(data.table)
weathter_data = fread("data/weather_data_for_modelling.csv")
soybean_data = fread("data/soybean_data_for_modelling.csv")
# only keep the necessary subset of the weather data
Weather_data_sub <- subset(weathter_data,as.character(Date)%in%as.character(c(soybean_data$Date,soybean_data$date_of_sowing)))
# include weather at sowing as varible
WeatherAtSowing <- unique(Weather_data_sub)
WeatherAtSowing$WeatherValueAtSowing <- WeatherAtSowing$WeatherValue
PhenoWeatherData <- merge.data.table(soybean_data, Weather_data_sub, by=c("Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- merge.data.table(PhenoWeatherData, WeatherAtSowing[,c("Location","Date","Year","WeatherVariable","WeatherValueAtSowing")], by.x=c("WeatherVariable","Location","date_of_sowing","Year"), by.y=c("WeatherVariable","Location","Date","Year"), all.x = T, all.y = F, allow.cartesian=TRUE)
PhenoWeatherData <- PhenoWeatherData[!is.na(PhenoWeatherData$WeatherVariable),]
# sowing to measure variables
PhenoWeatherData$Sowing_to_Measure <- PhenoWeatherData$WeatherValue-PhenoWeatherData$WeatherValueAtSowing
PhenoWeatherData <- PhenoWeatherData[order(PhenoWeatherData$Date),]
# calculate new measures : still unclear
# commented out on 2.4 based on changes made in the original repo:
#PhenoWeatherData <- PhenoWeatherData[,list(Sowing_to_Measure=mean(Sowing_to_Measure, na.rm=T), Measure_7=mean(Measure_7, na.rm=T), Measure_14=mean(Measure_14, na.rm=T), Measure_56=mean(Measure_56, na.rm=T), Measure_28=mean(Measure_28, na.rm=T)), by=.(Filename,genotype.name,genotype.id,Year,Location,year_site.UID,plot_number,plot.UID,plot_grouped,range,row,Date,value,variable,variable.1,WeatherVariable,WeatherCalcVar,date_of_sowing, platform)]
PhenoWeatherData_cast <- dcast.data.table(PhenoWeatherData, Filename+genotype.name+genotype.id+Year+Location+year_site.UID+plot_number+plot.UID+plot_grouped+range+row+Date+value+variable+variable.1+date_of_sowing+platform~WeatherVariable, value.var=c("Sowing_to_Measure","Measure_7","Measure_14","Measure_56","Measure_28")) # ~WeatherVariable+WeatherCalcVar
# make changes that were made in the original modelling file -----
# create new variables
PhenoWeatherData_cast$time_since_sowing =( as.numeric(as.Date(PhenoWeatherData_cast$Date )-as.Date( PhenoWeatherData_cast$date_of_sowing)))
model_df = data.frame(matrix(nrow=nrow(PhenoWeatherData_cast), ncol=0))
model_df$UID          <- PhenoWeatherData_cast$plot.UID
model_df$year         <- PhenoWeatherData_cast$Year
model_df$value <- PhenoWeatherData_cast$value
model_df$time_since_sowing <- PhenoWeatherData_cast$time_since_sowing
model_df$genotype.id  <- PhenoWeatherData_cast$genotype.id
model_df$date         <- PhenoWeatherData_cast$Date
model_df$plot_grouped <- PhenoWeatherData_cast$plot_grouped
model_df$year_site.UID <- PhenoWeatherData_cast$year_site.UID
model_df$range <- PhenoWeatherData_cast$range
model_df$row <- PhenoWeatherData_cast$row
model_df$Filename <- PhenoWeatherData_cast$Filename
model_df$Location <- PhenoWeatherData_cast$Location
model_df$platform = PhenoWeatherData_cast$platform
# type conversiion
model_df$year          <- ordered(as.numeric(model_df$year))
model_df$genotype.id   <- as.factor(model_df$genotype.id)
model_df$plot_grouped   <- ordered(as.factor(model_df$plot_grouped))
model_df$date          <- as.Date(model_df$date)
# measure variables
model_df$avg_Temperature_56 <- (PhenoWeatherData_cast$Measure_56_Temperature)
model_df$avg_Temperature_28 <- (PhenoWeatherData_cast$Measure_28_Temperature)
model_df$avg_precipitation_56 <- (PhenoWeatherData_cast$Measure_56_Precipitation)
model_df$avg_precipitation_28 <- (PhenoWeatherData_cast$Measure_28_Precipitation)
model_df$avg_radiation_28 <- (PhenoWeatherData_cast$Measure_28_RadiationSqrt)
model_df$avg_photothermal_14 <- (PhenoWeatherData_cast$Measure_28_PhotoSqrtThermal)
model_df$avg_vpd_28 <- (PhenoWeatherData_cast$Measure_28_VPD)
model_df$avg_humidity_28 <- (PhenoWeatherData_cast$Measure_28_Humidity)
###### add row per plot information
model_df$Row_per_plot <- 3
model_df$Row_per_plot[model_df$year_site.UID%in%c("FPSB004","FPSB005","FPSB007")] <- 9
######
model_df <- model_df[!is.na(model_df$value),]
model_df <- model_df[!is.nan(model_df$value),]
model_df <- model_df[!is.na(model_df$genotype.id),]
###### create new grouping. up for changing
setDT(model_df)[,length(unique(UID)),by=plot_grouped]
df_for_grouping = model_df[,c("range","row","year_site.UID")]
df_for_grouping = unique(df_for_grouping)
df_for_grouping <- df_for_grouping[order(df_for_grouping$year_site.UID,df_for_grouping$row, df_for_grouping$range),]
df_for_grouping$row_reduced <- round((df_for_grouping$row+2)/4, digits = 0)*4
df_for_grouping$range_reduced <- round((df_for_grouping$range+1)/2, digits = 0)*2
# MISTAKE here
df_for_grouping$plot_grouped_global <-  df_for_grouping$row_reduced * df_for_grouping$range_reduced
# unclear definitions of the global
df_for_grouping[,plot_grouped_sum:=max(plot_grouped_global),by=.(range,year_site.UID)]
df_for_grouping <- df_for_grouping[order(df_for_grouping$year_site.UID,df_for_grouping$plot_grouped_sum),]
df_for_grouping2 <- df_for_grouping
df_for_grouping <- df_for_grouping[,c("plot_grouped_sum","year_site.UID")]
df_for_grouping <- unique(df_for_grouping)
df_for_grouping$plot_grouped_sum_overall <- cumsum(df_for_grouping$plot_grouped_sum)
df_for_grouping$plot_grouped_sum_overall <- shift(df_for_grouping$plot_grouped_sum_overall,fill=0)
df_for_grouping3 <- merge(df_for_grouping2,df_for_grouping,by=c("year_site.UID","plot_grouped_sum"))
df_for_grouping3$plot_grouped_global <- df_for_grouping3$plot_grouped_sum_overall+df_for_grouping3$plot_grouped_global
df <- merge(df_for_grouping3, model_df,by=c("range","row","year_site.UID"))
df$plot_grouped_global <- ordered(as.factor(df$plot_grouped_global))
levels(df$plot_grouped_global) <- as.character(seq_along(levels(df$plot_grouped_global)))
# save file -----
write.csv(df, "data/model_data.csv")
